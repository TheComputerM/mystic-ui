{"name":"animated-beam","dependencies":["motion"],"files":[{"name":"animated-beam.tsx","tailwind":"import { cn } from \"@/lib/utils\";\nimport { animate } from \"motion\";\nimport {\n\ttype Component,\n\tcreateEffect,\n\tcreateSignal,\n\tcreateUniqueId,\n\tmergeProps,\n\tonMount,\n} from \"solid-js\";\n\nexport interface AnimatedBeamProps {\n\tclass?: string;\n\tcontainerRef: HTMLElement;\n\tfromRef: HTMLElement;\n\ttoRef: HTMLElement;\n\tcurvature?: number;\n\treverse?: boolean;\n\tpathColor?: string;\n\tpathWidth?: number;\n\tpathOpacity?: number;\n\tgradientStartColor?: string;\n\tgradientStopColor?: string;\n\tdelay?: number;\n\tduration?: number;\n\tstartXOffset?: number;\n\tstartYOffset?: number;\n\tendXOffset?: number;\n\tendYOffset?: number;\n}\n\nexport const AnimatedBeam: Component<AnimatedBeamProps> = (_props) => {\n\tconst props = mergeProps(\n\t\t{\n\t\t\tcurvature: 0,\n\t\t\treverse: false, // Include the reverse prop\n\t\t\tduration: Math.random() * 3 + 4,\n\t\t\tdelay: 0,\n\t\t\tpathColor: \"gray\",\n\t\t\tpathWidth: 2,\n\t\t\tpathOpacity: 0.2,\n\t\t\tgradientStartColor: \"#ffaa40\",\n\t\t\tgradientStopColor: \"#9c40ff\",\n\t\t\tstartXOffset: 0,\n\t\t\tstartYOffset: 0,\n\t\t\tendXOffset: 0,\n\t\t\tendYOffset: 0,\n\t\t},\n\t\t_props,\n\t);\n\n\tconst id = createUniqueId();\n\tconst [pathD, setPathD] = createSignal(\"\");\n\tconst [svgDimensions, setSvgDimensions] = createSignal({\n\t\twidth: 0,\n\t\theight: 0,\n\t});\n\n\t// Calculate the gradient coordinates based on the reverse prop\n\tconst gradientCoordinates = props.reverse\n\t\t? {\n\t\t\t\tx1: [90, -10],\n\t\t\t\tx2: [100, 0],\n\t\t\t\ty1: [0, 0],\n\t\t\t\ty2: [0, 0],\n\t\t\t}\n\t\t: {\n\t\t\t\tx1: [10, 110],\n\t\t\t\tx2: [0, 100],\n\t\t\t\ty1: [0, 0],\n\t\t\t\ty2: [0, 0],\n\t\t\t};\n\n\tcreateEffect(() => {\n\t\tconst updatePath = () => {\n\t\t\tif (props.containerRef && props.fromRef && props.toRef) {\n\t\t\t\tconst containerRect = props.containerRef.getBoundingClientRect();\n\t\t\t\tconst rectA = props.fromRef.getBoundingClientRect();\n\t\t\t\tconst rectB = props.toRef.getBoundingClientRect();\n\n\t\t\t\tconst svgWidth = containerRect.width;\n\t\t\t\tconst svgHeight = containerRect.height;\n\t\t\t\tsetSvgDimensions({ width: svgWidth, height: svgHeight });\n\n\t\t\t\tconst startX =\n\t\t\t\t\trectA.left -\n\t\t\t\t\tcontainerRect.left +\n\t\t\t\t\trectA.width / 2 +\n\t\t\t\t\tprops.startXOffset;\n\t\t\t\tconst startY =\n\t\t\t\t\trectA.top - containerRect.top + rectA.height / 2 + props.startYOffset;\n\t\t\t\tconst endX =\n\t\t\t\t\trectB.left - containerRect.left + rectB.width / 2 + props.endXOffset;\n\t\t\t\tconst endY =\n\t\t\t\t\trectB.top - containerRect.top + rectB.height / 2 + props.endYOffset;\n\n\t\t\t\tconst controlY = startY - props.curvature;\n\t\t\t\tconst d = `M ${startX},${startY} Q ${\n\t\t\t\t\t(startX + endX) / 2\n\t\t\t\t},${controlY} ${endX},${endY}`;\n\t\t\t\tsetPathD(d);\n\t\t\t}\n\t\t};\n\n\t\t// Initialize ResizeObserver\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\t// For all entries, recalculate the path\n\t\t\tfor (const entry of entries) {\n\t\t\t\tupdatePath();\n\t\t\t}\n\t\t});\n\n\t\t// Observe the container element\n\t\tif (props.containerRef) {\n\t\t\tresizeObserver.observe(props.containerRef);\n\t\t}\n\n\t\t// Call the updatePath initially to set the initial path\n\t\tupdatePath();\n\n\t\t// Clean up the observer on component unmount\n\t\treturn () => {\n\t\t\tresizeObserver.disconnect();\n\t\t};\n\t});\n\n\tlet linearGradient!: SVGLinearGradientElement;\n\tonMount(() => {\n\t\tconst controls = animate(\n\t\t\t(p) => {\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"x1\",\n\t\t\t\t\t`${\n\t\t\t\t\t\tgradientCoordinates.x1[1] * p + gradientCoordinates.x1[0] * (1 - p)\n\t\t\t\t\t}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"x2\",\n\t\t\t\t\t`${\n\t\t\t\t\t\tgradientCoordinates.x2[1] * p + gradientCoordinates.x2[0] * (1 - p)\n\t\t\t\t\t}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"y1\",\n\t\t\t\t\t`${\n\t\t\t\t\t\tgradientCoordinates.y1[1] * p + gradientCoordinates.y1[0] * (1 - p)\n\t\t\t\t\t}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"y2\",\n\t\t\t\t\t`${\n\t\t\t\t\t\tgradientCoordinates.y2[1] * p + gradientCoordinates.y2[0] * (1 - p)\n\t\t\t\t\t}%`,\n\t\t\t\t);\n\t\t\t},\n\t\t\t{\n\t\t\t\tdelay: props.delay,\n\t\t\t\tduration: props.duration,\n\t\t\t\teasing: [0.16, 1, 0.3, 1], // https://easings.net/#easeOutExpo\n\t\t\t\trepeat: Number.POSITIVE_INFINITY,\n\t\t\t},\n\t\t);\n\n\t\treturn () => controls.stop();\n\t});\n\n\treturn (\n\t\t<svg\n\t\t\tfill=\"none\"\n\t\t\taria-hidden=\"true\"\n\t\t\twidth={svgDimensions().width}\n\t\t\theight={svgDimensions().height}\n\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\tclass={cn(\n\t\t\t\t\"pointer-events-none absolute left-0 top-0 transform-gpu stroke-2\",\n\t\t\t\tprops.class,\n\t\t\t)}\n\t\t\tviewBox={`0 0 ${svgDimensions().width} ${svgDimensions().height}`}\n\t\t>\n\t\t\t<path\n\t\t\t\td={pathD()}\n\t\t\t\tstroke={props.pathColor}\n\t\t\t\tstroke-width={props.pathWidth}\n\t\t\t\tstroke-opacity={props.pathOpacity}\n\t\t\t\tstroke-linecap=\"round\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td={pathD()}\n\t\t\t\tstroke-width={props.pathWidth}\n\t\t\t\tstroke={`url(#${id})`}\n\t\t\t\tstroke-opacity=\"1\"\n\t\t\t\tstroke-linecap=\"round\"\n\t\t\t/>\n\t\t\t<defs>\n\t\t\t\t<linearGradient\n\t\t\t\t\tclass=\"transform-gpu\"\n\t\t\t\t\tid={id}\n\t\t\t\t\tgradientUnits=\"userSpaceOnUse\"\n\t\t\t\t\tref={linearGradient}\n\t\t\t\t>\n\t\t\t\t\t<stop stop-color={props.gradientStartColor} stop-opacity=\"0\" />\n\t\t\t\t\t<stop stop-color={props.gradientStartColor} />\n\t\t\t\t\t<stop offset=\"32.5%\" stop-color={props.gradientStopColor} />\n\t\t\t\t\t<stop\n\t\t\t\t\t\toffset=\"100%\"\n\t\t\t\t\t\tstop-color={props.gradientStopColor}\n\t\t\t\t\t\tstop-opacity=\"0\"\n\t\t\t\t\t/>\n\t\t\t\t</linearGradient>\n\t\t\t</defs>\n\t\t</svg>\n\t);\n};\n"}]}