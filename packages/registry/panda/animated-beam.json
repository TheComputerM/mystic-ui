{"id":"animated-beam","dependencies":["motion"],"content":"import { animate } from \"motion\";\nimport {\n\ttype Component,\n\tcreateEffect,\n\tcreateSignal,\n\tcreateUniqueId,\n\tmergeProps,\n\tonMount,\n} from \"solid-js\";\nimport { css, cx } from \"styled-system/css\";\n\nexport interface AnimatedBeamProps {\n\tclass?: string;\n\tcontainerRef: HTMLElement;\n\tfromRef: HTMLElement;\n\ttoRef: HTMLElement;\n\tcurvature?: number;\n\treverse?: boolean;\n\tpathColor?: string;\n\tpathWidth?: number;\n\tpathOpacity?: number;\n\tgradientStartColor?: string;\n\tgradientStopColor?: string;\n\tdelay?: number;\n\tduration?: number;\n\tstartXOffset?: number;\n\tstartYOffset?: number;\n\tendXOffset?: number;\n\tendYOffset?: number;\n}\n\nexport const AnimatedBeam: Component<AnimatedBeamProps> = (props) => {\n\tconst localProps = mergeProps(\n\t\t{\n\t\t\tcurvature: 0,\n\t\t\treverse: false, // Include the reverse prop\n\t\t\tduration: Math.random() * 3 + 4,\n\t\t\tdelay: 0,\n\t\t\tpathColor: \"gray\",\n\t\t\tpathWidth: 2,\n\t\t\tpathOpacity: 0.2,\n\t\t\tgradientStartColor: \"#ffaa40\",\n\t\t\tgradientStopColor: \"#9c40ff\",\n\t\t\tstartXOffset: 0,\n\t\t\tstartYOffset: 0,\n\t\t\tendXOffset: 0,\n\t\t\tendYOffset: 0,\n\t\t},\n\t\tprops,\n\t);\n\n\tconst id = createUniqueId();\n\tconst [pathD, setPathD] = createSignal(\"\");\n\tconst [svgDimensions, setSvgDimensions] = createSignal({\n\t\twidth: 0,\n\t\theight: 0,\n\t});\n\n\t// Calculate the gradient coordinates based on the reverse prop\n\tconst gradientCoordinates = localProps.reverse\n\t\t? {\n\t\t\t\tx1: [90, -10],\n\t\t\t\tx2: [100, 0],\n\t\t\t\ty1: [0, 0],\n\t\t\t\ty2: [0, 0],\n\t\t\t}\n\t\t: {\n\t\t\t\tx1: [10, 110],\n\t\t\t\tx2: [0, 100],\n\t\t\t\ty1: [0, 0],\n\t\t\t\ty2: [0, 0],\n\t\t\t};\n\n\tcreateEffect(() => {\n\t\tconst updatePath = () => {\n\t\t\tif (localProps.containerRef && localProps.fromRef && localProps.toRef) {\n\t\t\t\tconst containerRect = localProps.containerRef.getBoundingClientRect();\n\t\t\t\tconst rectA = localProps.fromRef.getBoundingClientRect();\n\t\t\t\tconst rectB = localProps.toRef.getBoundingClientRect();\n\n\t\t\t\tconst svgWidth = containerRect.width;\n\t\t\t\tconst svgHeight = containerRect.height;\n\t\t\t\tsetSvgDimensions({ width: svgWidth, height: svgHeight });\n\n\t\t\t\tconst startX =\n\t\t\t\t\trectA.left -\n\t\t\t\t\tcontainerRect.left +\n\t\t\t\t\trectA.width / 2 +\n\t\t\t\t\tlocalProps.startXOffset;\n\t\t\t\tconst startY =\n\t\t\t\t\trectA.top -\n\t\t\t\t\tcontainerRect.top +\n\t\t\t\t\trectA.height / 2 +\n\t\t\t\t\tlocalProps.startYOffset;\n\t\t\t\tconst endX =\n\t\t\t\t\trectB.left -\n\t\t\t\t\tcontainerRect.left +\n\t\t\t\t\trectB.width / 2 +\n\t\t\t\t\tlocalProps.endXOffset;\n\t\t\t\tconst endY =\n\t\t\t\t\trectB.top -\n\t\t\t\t\tcontainerRect.top +\n\t\t\t\t\trectB.height / 2 +\n\t\t\t\t\tlocalProps.endYOffset;\n\n\t\t\t\tconst controlY = startY - localProps.curvature;\n\t\t\t\tconst d = `M ${startX},${startY} Q ${(startX + endX) / 2},${controlY} ${endX},${endY}`;\n\t\t\t\tsetPathD(d);\n\t\t\t}\n\t\t};\n\n\t\t// Initialize ResizeObserver\n\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\t// For all entries, recalculate the path\n\t\t\tfor (const entry of entries) {\n\t\t\t\tupdatePath();\n\t\t\t}\n\t\t});\n\n\t\t// Observe the container element\n\t\tif (localProps.containerRef) {\n\t\t\tresizeObserver.observe(localProps.containerRef);\n\t\t}\n\n\t\t// Call the updatePath initially to set the initial path\n\t\tupdatePath();\n\n\t\t// Clean up the observer on component unmount\n\t\treturn () => {\n\t\t\tresizeObserver.disconnect();\n\t\t};\n\t});\n\n\tlet linearGradient!: SVGLinearGradientElement;\n\tonMount(() => {\n\t\tconst controls = animate(\n\t\t\t(p) => {\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"x1\",\n\t\t\t\t\t`${gradientCoordinates.x1[1] * p + gradientCoordinates.x1[0] * (1 - p)}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"x2\",\n\t\t\t\t\t`${gradientCoordinates.x2[1] * p + gradientCoordinates.x2[0] * (1 - p)}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"y1\",\n\t\t\t\t\t`${gradientCoordinates.y1[1] * p + gradientCoordinates.y1[0] * (1 - p)}%`,\n\t\t\t\t);\n\t\t\t\tlinearGradient.setAttribute(\n\t\t\t\t\t\"y2\",\n\t\t\t\t\t`${gradientCoordinates.y2[1] * p + gradientCoordinates.y2[0] * (1 - p)}%`,\n\t\t\t\t);\n\t\t\t},\n\t\t\t{\n\t\t\t\tdelay: localProps.delay,\n\t\t\t\tduration: localProps.duration,\n\t\t\t\teasing: [0.16, 1, 0.3, 1], // https://easings.net/#easeOutExpo\n\t\t\t\trepeat: Number.POSITIVE_INFINITY,\n\t\t\t},\n\t\t);\n\n\t\treturn () => controls.stop();\n\t});\n\n\treturn (\n\t\t<svg\n\t\t\tfill=\"none\"\n\t\t\taria-hidden=\"true\"\n\t\t\twidth={svgDimensions().width}\n\t\t\theight={svgDimensions().height}\n\t\t\txmlns=\"http://www.w3.org/2000/svg\"\n\t\t\tclass={cx(\n\t\t\t\tcss({\n\t\t\t\t\tpointerEvents: \"none\",\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: \"0\",\n\t\t\t\t\ttop: \"0\",\n\t\t\t\t\tstrokeWidth: \"2\",\n\t\t\t\t}),\n\t\t\t\tlocalProps.class,\n\t\t\t)}\n\t\t\tviewBox={`0 0 ${svgDimensions().width} ${svgDimensions().height}`}\n\t\t>\n\t\t\t<path\n\t\t\t\td={pathD()}\n\t\t\t\tstroke={localProps.pathColor}\n\t\t\t\tstroke-width={localProps.pathWidth}\n\t\t\t\tstroke-opacity={localProps.pathOpacity}\n\t\t\t\tstroke-linecap=\"round\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td={pathD()}\n\t\t\t\tstroke-width={localProps.pathWidth}\n\t\t\t\tstroke={`url(#${id})`}\n\t\t\t\tstroke-opacity=\"1\"\n\t\t\t\tstroke-linecap=\"round\"\n\t\t\t/>\n\t\t\t<defs>\n\t\t\t\t<linearGradient\n\t\t\t\t\tid={id}\n\t\t\t\t\tgradientUnits=\"userSpaceOnUse\"\n\t\t\t\t\tref={linearGradient}\n\t\t\t\t>\n\t\t\t\t\t<stop stop-color={localProps.gradientStartColor} stop-opacity=\"0\" />\n\t\t\t\t\t<stop stop-color={localProps.gradientStartColor} />\n\t\t\t\t\t<stop offset=\"32.5%\" stop-color={localProps.gradientStopColor} />\n\t\t\t\t\t<stop\n\t\t\t\t\t\toffset=\"100%\"\n\t\t\t\t\t\tstop-color={localProps.gradientStopColor}\n\t\t\t\t\t\tstop-opacity=\"0\"\n\t\t\t\t\t/>\n\t\t\t\t</linearGradient>\n\t\t\t</defs>\n\t\t</svg>\n\t);\n};\n"}